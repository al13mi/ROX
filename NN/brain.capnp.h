// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: brain.capnp

#ifndef CAPNP_INCLUDED_85150b117366d14b_
#define CAPNP_INCLUDED_85150b117366d14b_

#include <capnp/generated-header-support.h>
#if !CAPNP_LITE
#include <capnp/capability.h>
#endif  // !CAPNP_LITE

#if CAPNP_VERSION != 5003
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif


namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(82d74e22b57a02f1);
CAPNP_DECLARE_SCHEMA(ca7d1e99212191ec);
CAPNP_DECLARE_SCHEMA(b3294d5e8ccc0eed);
CAPNP_DECLARE_SCHEMA(d1b1a814385fae90);
CAPNP_DECLARE_SCHEMA(f5ba73f2fc0136f3);
CAPNP_DECLARE_SCHEMA(d91c670a2e17efcc);
CAPNP_DECLARE_SCHEMA(dc3c4b324373e0b8);
CAPNP_DECLARE_SCHEMA(ec79500c47047931);
CAPNP_DECLARE_SCHEMA(e49f3aba7a756d79);
CAPNP_DECLARE_SCHEMA(a88ee4ea48578816);
CAPNP_DECLARE_SCHEMA(f7d5836ab97d7b7e);

}  // namespace schemas
}  // namespace capnp


struct Brain {
  Brain() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct Packet;
  struct Entry;
  struct ActualPriority;
  struct Priority;
  struct PredictParams;
  struct PredictResults;
  struct LearnParams;
  struct LearnResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(82d74e22b57a02f1)
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
  };
  #endif  // !CAPNP_LITE
};

struct Brain::Packet {
  Packet() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ca7d1e99212191ec, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct Brain::Entry {
  Entry() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b3294d5e8ccc0eed, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct Brain::ActualPriority {
  ActualPriority() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d1b1a814385fae90, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct Brain::Priority {
  Priority() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct ReadParams;
  struct ReadResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(f5ba73f2fc0136f3)
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
  };
  #endif  // !CAPNP_LITE
};

struct Brain::Priority::ReadParams {
  ReadParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d91c670a2e17efcc, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct Brain::Priority::ReadResults {
  ReadResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(dc3c4b324373e0b8, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct Brain::PredictParams {
  PredictParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ec79500c47047931, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct Brain::PredictResults {
  PredictResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e49f3aba7a756d79, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct Brain::LearnParams {
  LearnParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a88ee4ea48578816, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct Brain::LearnResults {
  LearnResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f7d5836ab97d7b7e, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

#if !CAPNP_LITE
class Brain::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef Brain Calls;
  typedef Brain Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::Brain::PredictParams,  ::Brain::PredictResults> predictRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::Brain::LearnParams,  ::Brain::LearnResults> learnRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class Brain::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef Brain Serves;

  ::kj::Promise<void> dispatchCall(uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::Brain::PredictParams PredictParams;
  typedef  ::Brain::PredictResults PredictResults;
  typedef ::capnp::CallContext<PredictParams, PredictResults> PredictContext;
  virtual ::kj::Promise<void> predict(PredictContext context);
  typedef  ::Brain::LearnParams LearnParams;
  typedef  ::Brain::LearnResults LearnResults;
  typedef ::capnp::CallContext<LearnParams, LearnResults> LearnContext;
  virtual ::kj::Promise<void> learn(LearnContext context);

  ::kj::Promise<void> dispatchCallInternal(uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class Brain::Packet::Reader {
public:
  typedef Packet Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasData() const;
  inline  ::capnp::List< ::Brain::Entry>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Brain::Packet::Builder {
public:
  typedef Packet Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasData();
  inline  ::capnp::List< ::Brain::Entry>::Builder getData();
  inline void setData( ::capnp::List< ::Brain::Entry>::Reader value);
  inline  ::capnp::List< ::Brain::Entry>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::Brain::Entry>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::Brain::Entry>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Brain::Packet::Pipeline {
public:
  typedef Packet Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Brain::Entry::Reader {
public:
  typedef Entry Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::uint8_t getValue() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Brain::Entry::Builder {
public:
  typedef Entry Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint8_t getValue();
  inline void setValue( ::uint8_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Brain::Entry::Pipeline {
public:
  typedef Entry Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Brain::ActualPriority::Reader {
public:
  typedef ActualPriority Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getValue() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Brain::ActualPriority::Builder {
public:
  typedef ActualPriority Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getValue();
  inline void setValue( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Brain::ActualPriority::Pipeline {
public:
  typedef ActualPriority Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class Brain::Priority::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef Brain::Priority Calls;
  typedef Brain::Priority Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::Brain::Priority::ReadParams,  ::Brain::Priority::ReadResults> readRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class Brain::Priority::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef Brain::Priority Serves;

  ::kj::Promise<void> dispatchCall(uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::Brain::Priority::ReadParams ReadParams;
  typedef  ::Brain::Priority::ReadResults ReadResults;
  typedef ::capnp::CallContext<ReadParams, ReadResults> ReadContext;
  virtual ::kj::Promise<void> read(ReadContext context);

  ::kj::Promise<void> dispatchCallInternal(uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class Brain::Priority::ReadParams::Reader {
public:
  typedef ReadParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Brain::Priority::ReadParams::Builder {
public:
  typedef ReadParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Brain::Priority::ReadParams::Pipeline {
public:
  typedef ReadParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Brain::Priority::ReadResults::Reader {
public:
  typedef ReadResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getValue() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Brain::Priority::ReadResults::Builder {
public:
  typedef ReadResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getValue();
  inline void setValue( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Brain::Priority::ReadResults::Pipeline {
public:
  typedef ReadResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Brain::PredictParams::Reader {
public:
  typedef PredictParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasPacket() const;
  inline  ::Brain::Packet::Reader getPacket() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Brain::PredictParams::Builder {
public:
  typedef PredictParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasPacket();
  inline  ::Brain::Packet::Builder getPacket();
  inline void setPacket( ::Brain::Packet::Reader value);
  inline  ::Brain::Packet::Builder initPacket();
  inline void adoptPacket(::capnp::Orphan< ::Brain::Packet>&& value);
  inline ::capnp::Orphan< ::Brain::Packet> disownPacket();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Brain::PredictParams::Pipeline {
public:
  typedef PredictParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::Brain::Packet::Pipeline getPacket();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Brain::PredictResults::Reader {
public:
  typedef PredictResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasPriority() const;
#if !CAPNP_LITE
  inline  ::Brain::Priority::Client getPriority() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Brain::PredictResults::Builder {
public:
  typedef PredictResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasPriority();
#if !CAPNP_LITE
  inline  ::Brain::Priority::Client getPriority();
  inline void setPriority( ::Brain::Priority::Client&& value);
  inline void setPriority( ::Brain::Priority::Client& value);
  inline void adoptPriority(::capnp::Orphan< ::Brain::Priority>&& value);
  inline ::capnp::Orphan< ::Brain::Priority> disownPriority();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Brain::PredictResults::Pipeline {
public:
  typedef PredictResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::Brain::Priority::Client getPriority();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Brain::LearnParams::Reader {
public:
  typedef LearnParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasPacket() const;
  inline  ::Brain::Packet::Reader getPacket() const;

  inline bool hasPriority() const;
  inline  ::Brain::ActualPriority::Reader getPriority() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Brain::LearnParams::Builder {
public:
  typedef LearnParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasPacket();
  inline  ::Brain::Packet::Builder getPacket();
  inline void setPacket( ::Brain::Packet::Reader value);
  inline  ::Brain::Packet::Builder initPacket();
  inline void adoptPacket(::capnp::Orphan< ::Brain::Packet>&& value);
  inline ::capnp::Orphan< ::Brain::Packet> disownPacket();

  inline bool hasPriority();
  inline  ::Brain::ActualPriority::Builder getPriority();
  inline void setPriority( ::Brain::ActualPriority::Reader value);
  inline  ::Brain::ActualPriority::Builder initPriority();
  inline void adoptPriority(::capnp::Orphan< ::Brain::ActualPriority>&& value);
  inline ::capnp::Orphan< ::Brain::ActualPriority> disownPriority();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Brain::LearnParams::Pipeline {
public:
  typedef LearnParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::Brain::Packet::Pipeline getPacket();
  inline  ::Brain::ActualPriority::Pipeline getPriority();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Brain::LearnResults::Reader {
public:
  typedef LearnResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Brain::LearnResults::Builder {
public:
  typedef LearnResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Brain::LearnResults::Pipeline {
public:
  typedef LearnResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

#if !CAPNP_LITE
inline Brain::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline Brain::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline Brain::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline Brain::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline Brain::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::Brain::Client& Brain::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::Brain::Client& Brain::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline bool Brain::Packet::Reader::hasData() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool Brain::Packet::Builder::hasData() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::Brain::Entry>::Reader Brain::Packet::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Brain::Entry>>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::Brain::Entry>::Builder Brain::Packet::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Brain::Entry>>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void Brain::Packet::Builder::setData( ::capnp::List< ::Brain::Entry>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Brain::Entry>>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::Brain::Entry>::Builder Brain::Packet::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Brain::Entry>>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS), size);
}
inline void Brain::Packet::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::Brain::Entry>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Brain::Entry>>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::Brain::Entry>> Brain::Packet::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Brain::Entry>>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline  ::uint8_t Brain::Entry::Reader::getValue() const {
  return _reader.getDataField< ::uint8_t>(
      0 * ::capnp::ELEMENTS);
}

inline  ::uint8_t Brain::Entry::Builder::getValue() {
  return _builder.getDataField< ::uint8_t>(
      0 * ::capnp::ELEMENTS);
}
inline void Brain::Entry::Builder::setValue( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      0 * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Brain::ActualPriority::Reader::getValue() const {
  return _reader.getDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS);
}

inline  ::uint32_t Brain::ActualPriority::Builder::getValue() {
  return _builder.getDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS);
}
inline void Brain::ActualPriority::Builder::setValue( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS, value);
}

#if !CAPNP_LITE
inline Brain::Priority::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline Brain::Priority::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline Brain::Priority::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline Brain::Priority::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline Brain::Priority::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::Brain::Priority::Client& Brain::Priority::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::Brain::Priority::Client& Brain::Priority::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline  ::uint32_t Brain::Priority::ReadResults::Reader::getValue() const {
  return _reader.getDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS);
}

inline  ::uint32_t Brain::Priority::ReadResults::Builder::getValue() {
  return _builder.getDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS);
}
inline void Brain::Priority::ReadResults::Builder::setValue( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS, value);
}

inline bool Brain::PredictParams::Reader::hasPacket() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool Brain::PredictParams::Builder::hasPacket() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::Brain::Packet::Reader Brain::PredictParams::Reader::getPacket() const {
  return ::capnp::_::PointerHelpers< ::Brain::Packet>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::Brain::Packet::Builder Brain::PredictParams::Builder::getPacket() {
  return ::capnp::_::PointerHelpers< ::Brain::Packet>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::Brain::Packet::Pipeline Brain::PredictParams::Pipeline::getPacket() {
  return  ::Brain::Packet::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Brain::PredictParams::Builder::setPacket( ::Brain::Packet::Reader value) {
  ::capnp::_::PointerHelpers< ::Brain::Packet>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::Brain::Packet::Builder Brain::PredictParams::Builder::initPacket() {
  return ::capnp::_::PointerHelpers< ::Brain::Packet>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void Brain::PredictParams::Builder::adoptPacket(
    ::capnp::Orphan< ::Brain::Packet>&& value) {
  ::capnp::_::PointerHelpers< ::Brain::Packet>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Brain::Packet> Brain::PredictParams::Builder::disownPacket() {
  return ::capnp::_::PointerHelpers< ::Brain::Packet>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool Brain::PredictResults::Reader::hasPriority() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool Brain::PredictResults::Builder::hasPriority() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::Brain::Priority::Client Brain::PredictResults::Reader::getPriority() const {
  return ::capnp::_::PointerHelpers< ::Brain::Priority>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::Brain::Priority::Client Brain::PredictResults::Builder::getPriority() {
  return ::capnp::_::PointerHelpers< ::Brain::Priority>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::Brain::Priority::Client Brain::PredictResults::Pipeline::getPriority() {
  return  ::Brain::Priority::Client(_typeless.getPointerField(0).asCap());
}
inline void Brain::PredictResults::Builder::setPriority( ::Brain::Priority::Client&& cap) {
  ::capnp::_::PointerHelpers< ::Brain::Priority>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(cap));
}
inline void Brain::PredictResults::Builder::setPriority( ::Brain::Priority::Client& cap) {
  ::capnp::_::PointerHelpers< ::Brain::Priority>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), cap);
}
inline void Brain::PredictResults::Builder::adoptPriority(
    ::capnp::Orphan< ::Brain::Priority>&& value) {
  ::capnp::_::PointerHelpers< ::Brain::Priority>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Brain::Priority> Brain::PredictResults::Builder::disownPriority() {
  return ::capnp::_::PointerHelpers< ::Brain::Priority>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool Brain::LearnParams::Reader::hasPacket() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool Brain::LearnParams::Builder::hasPacket() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::Brain::Packet::Reader Brain::LearnParams::Reader::getPacket() const {
  return ::capnp::_::PointerHelpers< ::Brain::Packet>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::Brain::Packet::Builder Brain::LearnParams::Builder::getPacket() {
  return ::capnp::_::PointerHelpers< ::Brain::Packet>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::Brain::Packet::Pipeline Brain::LearnParams::Pipeline::getPacket() {
  return  ::Brain::Packet::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Brain::LearnParams::Builder::setPacket( ::Brain::Packet::Reader value) {
  ::capnp::_::PointerHelpers< ::Brain::Packet>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::Brain::Packet::Builder Brain::LearnParams::Builder::initPacket() {
  return ::capnp::_::PointerHelpers< ::Brain::Packet>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void Brain::LearnParams::Builder::adoptPacket(
    ::capnp::Orphan< ::Brain::Packet>&& value) {
  ::capnp::_::PointerHelpers< ::Brain::Packet>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Brain::Packet> Brain::LearnParams::Builder::disownPacket() {
  return ::capnp::_::PointerHelpers< ::Brain::Packet>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool Brain::LearnParams::Reader::hasPriority() const {
  return !_reader.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline bool Brain::LearnParams::Builder::hasPriority() {
  return !_builder.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline  ::Brain::ActualPriority::Reader Brain::LearnParams::Reader::getPriority() const {
  return ::capnp::_::PointerHelpers< ::Brain::ActualPriority>::get(
      _reader.getPointerField(1 * ::capnp::POINTERS));
}
inline  ::Brain::ActualPriority::Builder Brain::LearnParams::Builder::getPriority() {
  return ::capnp::_::PointerHelpers< ::Brain::ActualPriority>::get(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::Brain::ActualPriority::Pipeline Brain::LearnParams::Pipeline::getPriority() {
  return  ::Brain::ActualPriority::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Brain::LearnParams::Builder::setPriority( ::Brain::ActualPriority::Reader value) {
  ::capnp::_::PointerHelpers< ::Brain::ActualPriority>::set(
      _builder.getPointerField(1 * ::capnp::POINTERS), value);
}
inline  ::Brain::ActualPriority::Builder Brain::LearnParams::Builder::initPriority() {
  return ::capnp::_::PointerHelpers< ::Brain::ActualPriority>::init(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
inline void Brain::LearnParams::Builder::adoptPriority(
    ::capnp::Orphan< ::Brain::ActualPriority>&& value) {
  ::capnp::_::PointerHelpers< ::Brain::ActualPriority>::adopt(
      _builder.getPointerField(1 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Brain::ActualPriority> Brain::LearnParams::Builder::disownPriority() {
  return ::capnp::_::PointerHelpers< ::Brain::ActualPriority>::disown(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}


#endif  // CAPNP_INCLUDED_85150b117366d14b_
